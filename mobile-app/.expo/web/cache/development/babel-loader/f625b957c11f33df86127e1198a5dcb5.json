{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { clamp, focusWithoutScrolling, mergeProps, useGlobalListeners } from '@react-aria/utils';\nimport { getSliderThumbId, sliderIds } from \"./utils\";\nimport { useCallback, useEffect, useRef } from 'react';\nimport { useFocusable } from '@react-aria/focus';\nimport { useLabel } from '@react-aria/label';\nimport { useMove } from \"./useMove\";\nimport { isRTL } from '@react-native-aria/utils';\nexport function useSliderThumb(opts, state) {\n  var _opts$ariaLabelledby;\n\n  var index = opts.index,\n      isRequired = opts.isRequired,\n      isDisabled = opts.isDisabled,\n      validationState = opts.validationState,\n      trackLayout = opts.trackLayout,\n      inputRef = opts.inputRef;\n  var isVertical = opts.orientation === 'vertical';\n  var direction = isRTL() ? 'rtl' : undefined;\n\n  var _useGlobalListeners = useGlobalListeners(),\n      addGlobalListener = _useGlobalListeners.addGlobalListener,\n      removeGlobalListener = _useGlobalListeners.removeGlobalListener;\n\n  var labelId = sliderIds.get(state);\n\n  var _useLabel = useLabel(_objectSpread(_objectSpread({}, opts), {}, {\n    'id': getSliderThumbId(state, index),\n    'aria-labelledby': (labelId + \" \" + ((_opts$ariaLabelledby = opts['aria-labelledby']) !== null && _opts$ariaLabelledby !== void 0 ? _opts$ariaLabelledby : '')).trim()\n  })),\n      labelProps = _useLabel.labelProps,\n      fieldProps = _useLabel.fieldProps;\n\n  var value = state.values[index];\n  var focusInput = useCallback(function () {\n    if (inputRef.current) {\n      focusWithoutScrolling(inputRef.current);\n    }\n  }, [inputRef]);\n  var isFocused = state.focusedThumb === index;\n  useEffect(function () {\n    if (isFocused) {\n      focusInput();\n    }\n  }, [isFocused, focusInput]);\n  var stateRef = useRef(null);\n  stateRef.current = state;\n  var reverseX = direction === 'rtl';\n  var currentPosition = useRef(null);\n\n  var _useMove = useMove({\n    onMoveStart: function onMoveStart() {\n      currentPosition.current = null;\n      state.setThumbDragging(index, true);\n    },\n    onMove: function onMove(_ref) {\n      var deltaX = _ref.deltaX,\n          deltaY = _ref.deltaY,\n          pointerType = _ref.pointerType;\n      var size = isVertical ? trackLayout.height : trackLayout.width;\n\n      if (currentPosition.current == null) {\n        currentPosition.current = stateRef.current.getThumbPercent(index) * size;\n      }\n\n      if (pointerType === 'keyboard') {\n        var delta = ((reverseX ? -deltaX : deltaX) + (isVertical ? -deltaY : -deltaY)) * stateRef.current.step;\n        currentPosition.current += delta * size;\n        stateRef.current.setThumbValue(index, stateRef.current.getThumbValue(index) + delta);\n      } else {\n        var _delta = isVertical ? deltaY : deltaX;\n\n        if (isVertical || reverseX) {\n          _delta = -_delta;\n        }\n\n        currentPosition.current += _delta;\n        stateRef.current.setThumbPercent(index, clamp(currentPosition.current / size, 0, 1));\n      }\n    },\n    onMoveEnd: function onMoveEnd() {\n      state.setThumbDragging(index, false);\n    }\n  }),\n      moveProps = _useMove.moveProps;\n\n  state.setThumbEditable(index, !isDisabled);\n\n  var _useFocusable = useFocusable(mergeProps(opts, {\n    onFocus: function onFocus() {\n      return state.setFocusedThumb(index);\n    },\n    onBlur: function onBlur() {\n      return state.setFocusedThumb(undefined);\n    }\n  }), inputRef),\n      focusableProps = _useFocusable.focusableProps;\n\n  var currentPointer = useRef(undefined);\n\n  var onDown = function onDown(id) {\n    focusInput();\n    currentPointer.current = id;\n    state.setThumbDragging(index, true);\n    addGlobalListener(window, 'mouseup', onUp, false);\n    addGlobalListener(window, 'touchend', onUp, false);\n    addGlobalListener(window, 'pointerup', onUp, false);\n  };\n\n  var onUp = function onUp(e) {\n    var _e$pointerId, _e$changedTouches;\n\n    var id = (_e$pointerId = e.pointerId) !== null && _e$pointerId !== void 0 ? _e$pointerId : (_e$changedTouches = e.changedTouches) === null || _e$changedTouches === void 0 ? void 0 : _e$changedTouches[0].identifier;\n\n    if (id === currentPointer.current) {\n      focusInput();\n      state.setThumbDragging(index, false);\n      removeGlobalListener(window, 'mouseup', onUp, false);\n      removeGlobalListener(window, 'touchend', onUp, false);\n      removeGlobalListener(window, 'pointerup', onUp, false);\n    }\n  };\n\n  return {\n    inputProps: mergeProps(focusableProps, fieldProps, {\n      'type': 'range',\n      'tabIndex': !isDisabled ? 0 : undefined,\n      'min': state.getThumbMinValue(index),\n      'max': state.getThumbMaxValue(index),\n      'step': state.step,\n      'value': value,\n      'disabled': isDisabled,\n      'aria-orientation': opts.orientation,\n      'aria-valuetext': state.getThumbValueLabel(index),\n      'aria-required': isRequired || undefined,\n      'aria-invalid': validationState === 'invalid' || undefined,\n      'aria-errormessage': opts['aria-errormessage'],\n      'onChange': function onChange(e) {\n        state.setThumbValue(index, parseFloat(e.target.value));\n      }\n    }),\n    thumbProps: !isDisabled ? mergeProps(moveProps, {\n      onMouseDown: function onMouseDown(e) {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n          return;\n        }\n\n        onDown();\n      },\n      onPointerDown: function onPointerDown(e) {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n          return;\n        }\n\n        onDown(e.pointerId);\n      },\n      onTouchStart: function onTouchStart(e) {\n        onDown(e.changedTouches[0].identifier);\n      }\n    }) : {},\n    labelProps: labelProps\n  };\n}","map":{"version":3,"sources":["useSliderThumb.web.ts"],"names":["inputRef","isVertical","opts","direction","isRTL","removeGlobalListener","useGlobalListeners","labelId","sliderIds","fieldProps","useLabel","getSliderThumbId","value","state","focusInput","useCallback","focusWithoutScrolling","isFocused","useEffect","stateRef","useRef","reverseX","currentPosition","moveProps","useMove","onMoveStart","onMove","pointerType","size","trackLayout","delta","clamp","onMoveEnd","focusableProps","useFocusable","mergeProps","onFocus","onBlur","currentPointer","onDown","id","addGlobalListener","onUp","e","inputProps","isRequired","validationState","parseFloat","thumbProps","onMouseDown","onPointerDown","onTouchStart","labelProps"],"mappings":";;;;;;AACA,SAAA,KAAA,EAAA,qBAAA,EAAA,UAAA,EAAA,kBAAA,QAAA,mBAAA;AAMA,SAAA,gBAAA,EAAA,SAAA;AACA,SAAA,WAAA,EAAA,SAAA,EAAA,MAAA,QAAA,OAAA;AAWA,SAAA,YAAA,QAAA,mBAAA;AACA,SAAA,QAAA,QAAA,mBAAA;AACA,SAAA,OAAA;AACA,SAAA,KAAA,QAAA,0BAAA;AA0BA,OAAO,SAAA,cAAA,CAAA,IAAA,EAAA,KAAA,EAGY;AAAA,MAAA,oBAAA;;AACjB,MAAI,KAAJ,GAAA,IAAA,CAAI,KAAJ;AAAA,MAAI,UAAJ,GAAA,IAAA,CAAI,UAAJ;AAAA,MAAI,UAAJ,GAAA,IAAA,CAAI,UAAJ;AAAA,MAAI,eAAJ,GAAA,IAAA,CAAI,eAAJ;AAAA,MAAI,WAAJ,GAAA,IAAA,CAAI,WAAJ;AAAA,MAMEA,QANF,GAAA,IAAA,CAMEA,QANF;AASA,MAAIC,UAAU,GAAGC,IAAI,CAAJA,WAAAA,KAAjB,UAAA;AAEA,MAAIC,SAAS,GAAGC,KAAK,KAAA,KAAA,GAArB,SAAA;;AACA,4BAAkDE,kBAAlD,EAAA;AAAA,MAAI,iBAAJ,uBAAI,iBAAJ;AAAA,MAAyBD,oBAAzB,uBAAyBA,oBAAzB;;AAEA,MAAIE,OAAO,GAAGC,SAAS,CAATA,GAAAA,CAAd,KAAcA,CAAd;;AACA,kBAAmCE,QAAQ,iCAAC,IAAD;AAEzC,UAAMC,gBAAgB,CAAA,KAAA,EAFoB,KAEpB,CAFmB;AAGzC,uBAAoB,CAAEJ,OAAF,UAAD,CAAA,oBAAA,GAAcL,IAAI,CAAlB,iBAAkB,CAAlB,MAAA,IAAA,IAAA,oBAAA,KAAA,KAAA,CAAA,GAAA,oBAAA,GAAA,EAAC,GAAD,IAAC;AAHqB,KAA3C;AAAA,MAAM,UAAN,aAAM,UAAN;AAAA,MAAoBO,UAApB,aAAoBA,UAApB;;AAMA,MAAMG,KAAK,GAAGC,KAAK,CAALA,MAAAA,CAAd,KAAcA,CAAd;AAEA,MAAMC,UAAU,GAAGC,WAAW,CAAC,YAAM;AACnC,QAAIf,QAAQ,CAAZ,OAAA,EAAsB;AACpBgB,MAAAA,qBAAqB,CAAChB,QAAQ,CAA9BgB,OAAqB,CAArBA;AACD;AAH2B,GAAA,EAI3B,CAJH,QAIG,CAJ2B,CAA9B;AAMA,MAAMC,SAAS,GAAGJ,KAAK,CAALA,YAAAA,KAAlB,KAAA;AAEAK,EAAAA,SAAS,CAAC,YAAM;AACd,QAAA,SAAA,EAAe;AACbJ,MAAAA,UAAU;AACX;AAHM,GAAA,EAIN,CAAA,SAAA,EAJHI,UAIG,CAJM,CAATA;AAMA,MAAMC,QAAQ,GAAGC,MAAM,CAAvB,IAAuB,CAAvB;AACAD,EAAAA,QAAQ,CAARA,OAAAA,GAAAA,KAAAA;AACA,MAAIE,QAAQ,GAAGlB,SAAS,KAAxB,KAAA;AACA,MAAImB,eAAe,GAAGF,MAAM,CAA5B,IAA4B,CAA5B;;AACA,iBAAoBI,OAAO,CAAC;AAC1BC,IAAAA,WAD0B,yBACZ;AACZH,MAAAA,eAAe,CAAfA,OAAAA,GAAAA,IAAAA;AACAT,MAAAA,KAAK,CAALA,gBAAAA,CAAAA,KAAAA,EAAAA,IAAAA;AAHwB,KAAA;AAK1Ba,IAAAA,MAL0B,wBAKc;AAAA,UAAjC,MAAiC,QAAjC,MAAiC;AAAA,UAAjC,MAAiC,QAAjC,MAAiC;AAAA,UAAfC,WAAe,QAAfA,WAAe;AACtC,UAAIC,IAAI,GAAG3B,UAAU,GAAG4B,WAAW,CAAd,MAAA,GAAwBA,WAAW,CAAxD,KAAA;;AAEA,UAAIP,eAAe,CAAfA,OAAAA,IAAJ,IAAA,EAAqC;AACnCA,QAAAA,eAAe,CAAfA,OAAAA,GACEH,QAAQ,CAARA,OAAAA,CAAAA,eAAAA,CAAAA,KAAAA,IADFG,IAAAA;AAED;;AACD,UAAIK,WAAW,KAAf,UAAA,EAAgC;AAE9B,YAAIG,KAAK,GACP,CAAC,CAACT,QAAQ,GAAG,CAAH,MAAA,GAAT,MAAA,KAAiCpB,UAAU,GAAG,CAAH,MAAA,GAAa,CAAzD,MAAC,CAAD,IACAkB,QAAQ,CAARA,OAAAA,CAFF,IAAA;AAGAG,QAAAA,eAAe,CAAfA,OAAAA,IAA2BQ,KAAK,GAAhCR,IAAAA;AACAH,QAAAA,QAAQ,CAARA,OAAAA,CAAAA,aAAAA,CAAAA,KAAAA,EAEEA,QAAQ,CAARA,OAAAA,CAAAA,aAAAA,CAAAA,KAAAA,IAFFA,KAAAA;AANF,OAAA,MAUO;AACL,YAAIW,MAAK,GAAG7B,UAAU,GAAA,MAAA,GAAtB,MAAA;;AACA,YAAIA,UAAU,IAAd,QAAA,EAA4B;AAC1B6B,UAAAA,MAAK,GAAG,CAARA,MAAAA;AACD;;AACDR,QAAAA,eAAe,CAAfA,OAAAA,IAAAA,MAAAA;AACAH,QAAAA,QAAQ,CAARA,OAAAA,CAAAA,eAAAA,CAAAA,KAAAA,EAEEY,KAAK,CAACT,eAAe,CAAfA,OAAAA,GAAD,IAAA,EAAA,CAAA,EAFPH,CAEO,CAFPA;AAID;AAhCuB,KAAA;AAkC1Ba,IAAAA,SAlC0B,uBAkCd;AACVnB,MAAAA,KAAK,CAALA,gBAAAA,CAAAA,KAAAA,EAAAA,KAAAA;AACD;AApCyB,GAAD,CAA3B;AAAA,MAAMU,SAAN,YAAMA,SAAN;;AAwCAV,EAAAA,KAAK,CAALA,gBAAAA,CAAAA,KAAAA,EAA8B,CAA9BA,UAAAA;;AAEA,sBAA2BqB,YAAY,CACrCC,UAAU,CAAA,IAAA,EAAO;AACfC,IAAAA,OAAO,EAAE;AAAA,aAAMvB,KAAK,CAALA,eAAAA,CADA,KACAA,CAAN;AAAA,KADM;AAEfwB,IAAAA,MAAM,EAAE;AAAA,aAAMxB,KAAK,CAALA,eAAAA,CAAAA,SAAAA,CAAN;AAAA;AAFO,GAAP,CAD2B,EAAvC,QAAuC,CAAvC;AAAA,MAAQoB,cAAR,iBAAQA,cAAR;;AAQA,MAAIK,cAAc,GAAGlB,MAAM,CAA3B,SAA2B,CAA3B;;AACA,MAAImB,MAAM,GAAIC,SAAVD,MAAUC,CAAAA,EAAD,EAAiB;AAC5B1B,IAAAA,UAAU;AACVwB,IAAAA,cAAc,CAAdA,OAAAA,GAAAA,EAAAA;AACAzB,IAAAA,KAAK,CAALA,gBAAAA,CAAAA,KAAAA,EAAAA,IAAAA;AAEA4B,IAAAA,iBAAiB,CAAA,MAAA,EAAA,SAAA,EAAA,IAAA,EAAjBA,KAAiB,CAAjBA;AACAA,IAAAA,iBAAiB,CAAA,MAAA,EAAA,UAAA,EAAA,IAAA,EAAjBA,KAAiB,CAAjBA;AACAA,IAAAA,iBAAiB,CAAA,MAAA,EAAA,WAAA,EAAA,IAAA,EAAjBA,KAAiB,CAAjBA;AAPF,GAAA;;AAUA,MAAIC,IAAI,GAAIC,SAARD,IAAQC,CAAAA,CAAD,EAAO;AAAA,QAAA,YAAA,EAAA,iBAAA;;AAChB,QAAIH,EAAE,GAAA,CAAA,YAAA,GAAGG,CAAC,CAAJ,SAAA,MAAA,IAAA,IAAA,YAAA,KAAA,KAAA,CAAA,GAAA,YAAA,GAAA,CAAA,iBAAA,GAAkBA,CAAC,CAAnB,cAAA,MAAA,IAAA,IAAA,iBAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAkBA,iBAAAA,CAAAA,CAAAA,CAAAA,CAAxB,UAAA;;AACA,QAAIH,EAAE,KAAKF,cAAc,CAAzB,OAAA,EAAmC;AACjCxB,MAAAA,UAAU;AACVD,MAAAA,KAAK,CAALA,gBAAAA,CAAAA,KAAAA,EAAAA,KAAAA;AACAR,MAAAA,oBAAoB,CAAA,MAAA,EAAA,SAAA,EAAA,IAAA,EAApBA,KAAoB,CAApBA;AACAA,MAAAA,oBAAoB,CAAA,MAAA,EAAA,UAAA,EAAA,IAAA,EAApBA,KAAoB,CAApBA;AACAA,MAAAA,oBAAoB,CAAA,MAAA,EAAA,WAAA,EAAA,IAAA,EAApBA,KAAoB,CAApBA;AACD;AA/Gc,GAuGjB;;AAeA,SAAO;AACLuC,IAAAA,UAAU,EAAET,UAAU,CAAA,cAAA,EAAA,UAAA,EAA6B;AACjD,cADiD,OAAA;AAEjD,kBAAY,CAAA,UAAA,GAAA,CAAA,GAFqC,SAAA;AAGjD,aAAOtB,KAAK,CAALA,gBAAAA,CAH0C,KAG1CA,CAH0C;AAIjD,aAAOA,KAAK,CAALA,gBAAAA,CAJ0C,KAI1CA,CAJ0C;AAKjD,cAAQA,KAAK,CALoC,IAAA;AAMjD,eANiD,KAAA;AAOjD,kBAPiD,UAAA;AAQjD,0BAAoBX,IAAI,CARyB,WAAA;AASjD,wBAAkBW,KAAK,CAALA,kBAAAA,CAT+B,KAS/BA,CAT+B;AAUjD,uBAAiBgC,UAAU,IAVsB,SAAA;AAWjD,sBAAgBC,eAAe,KAAfA,SAAAA,IAXiC,SAAA;AAYjD,2BAAqB5C,IAAI,CAZwB,mBAYxB,CAZwB;AAajD,kBAAayC,kBAAAA,CAAD,EAAsC;AAChD9B,QAAAA,KAAK,CAALA,aAAAA,CAAAA,KAAAA,EAA2BkC,UAAU,CAACJ,CAAC,CAADA,MAAAA,CAAtC9B,KAAqC,CAArCA;AACD;AAfgD,KAA7B,CADjB;AAkBLmC,IAAAA,UAAU,EAAE,CAAA,UAAA,GACRb,UAAU,CAAA,SAAA,EAAY;AACpBc,MAAAA,WAAW,EAAGN,qBAAAA,CAAD,EAAsC;AACjD,YAAIA,CAAC,CAADA,MAAAA,KAAAA,CAAAA,IAAkBA,CAAC,CAAnBA,MAAAA,IAA8BA,CAAC,CAA/BA,OAAAA,IAA2CA,CAAC,CAAhD,OAAA,EAA0D;AACxD;AACD;;AACDJ,QAAAA,MAAM;AALY,OAAA;AAOpBW,MAAAA,aAAa,EAAGP,uBAAAA,CAAD,EAAwC;AACrD,YAAIA,CAAC,CAADA,MAAAA,KAAAA,CAAAA,IAAkBA,CAAC,CAAnBA,MAAAA,IAA8BA,CAAC,CAA/BA,OAAAA,IAA2CA,CAAC,CAAhD,OAAA,EAA0D;AACxD;AACD;;AACDJ,QAAAA,MAAM,CAACI,CAAC,CAARJ,SAAM,CAANA;AAXkB,OAAA;AAapBY,MAAAA,YAAY,EAAGR,sBAAAA,CAAD,EAAsC;AAClDJ,QAAAA,MAAM,CAACI,CAAC,CAADA,cAAAA,CAAAA,CAAAA,EAAPJ,UAAM,CAANA;AACD;AAfmB,KAAZ,CADF,GAlBP,EAAA;AAqCLa,IAAAA,UAAAA,EAAAA;AArCK,GAAP;AAuCD","sourcesContent":["import { AriaSliderThumbProps } from '@react-types/slider';\nimport {\n  clamp,\n  focusWithoutScrolling,\n  mergeProps,\n  useGlobalListeners,\n} from '@react-aria/utils';\nimport { getSliderThumbId, sliderIds } from './utils';\nimport React, {\n  ChangeEvent,\n  HTMLAttributes,\n  InputHTMLAttributes,\n  LabelHTMLAttributes,\n  RefObject,\n  useCallback,\n  useEffect,\n  useRef,\n} from 'react';\nimport { SliderState } from '@react-stately/slider';\nimport { useFocusable } from '@react-aria/focus';\nimport { useLabel } from '@react-aria/label';\nimport { useMove } from './useMove';\nimport { isRTL } from '@react-native-aria/utils';\n\ninterface SliderThumbAria {\n  /** Props for the root thumb element; handles the dragging motion. */\n  thumbProps: HTMLAttributes<HTMLElement>;\n\n  /** Props for the visually hidden range input element. */\n  inputProps: InputHTMLAttributes<HTMLInputElement>;\n\n  /** Props for the label element for this thumb (optional). */\n  labelProps: LabelHTMLAttributes<HTMLLabelElement>;\n}\n\ninterface SliderThumbOptions extends AriaSliderThumbProps {\n  /** A ref to the track element. */\n  trackLayout: any;\n  /** A ref to the thumb input element. */\n  inputRef: RefObject<HTMLInputElement>;\n}\n\n/**\n * Provides behavior and accessibility for a thumb of a slider component.\n *\n * @param opts Options for this Slider thumb.\n * @param state Slider state, created via `useSliderState`.\n */\nexport function useSliderThumb(\n  opts: SliderThumbOptions,\n  state: SliderState\n): SliderThumbAria {\n  let {\n    index,\n    isRequired,\n    isDisabled,\n    validationState,\n    trackLayout,\n    inputRef,\n  } = opts;\n\n  let isVertical = opts.orientation === 'vertical';\n\n  let direction = isRTL() ? 'rtl' : undefined;\n  let { addGlobalListener, removeGlobalListener } = useGlobalListeners();\n\n  let labelId = sliderIds.get(state);\n  const { labelProps, fieldProps } = useLabel({\n    ...opts,\n    'id': getSliderThumbId(state, index),\n    'aria-labelledby': `${labelId} ${opts['aria-labelledby'] ?? ''}`.trim(),\n  });\n\n  const value = state.values[index];\n\n  const focusInput = useCallback(() => {\n    if (inputRef.current) {\n      focusWithoutScrolling(inputRef.current);\n    }\n  }, [inputRef]);\n\n  const isFocused = state.focusedThumb === index;\n\n  useEffect(() => {\n    if (isFocused) {\n      focusInput();\n    }\n  }, [isFocused, focusInput]);\n\n  const stateRef = useRef<SliderState>(null);\n  stateRef.current = state;\n  let reverseX = direction === 'rtl';\n  let currentPosition = useRef<number>(null);\n  let { moveProps } = useMove({\n    onMoveStart() {\n      currentPosition.current = null;\n      state.setThumbDragging(index, true);\n    },\n    onMove({ deltaX, deltaY, pointerType }) {\n      let size = isVertical ? trackLayout.height : trackLayout.width;\n\n      if (currentPosition.current == null) {\n        currentPosition.current =\n          stateRef.current.getThumbPercent(index) * size;\n      }\n      if (pointerType === 'keyboard') {\n        // (invert left/right according to language direction) + (according to vertical)\n        let delta =\n          ((reverseX ? -deltaX : deltaX) + (isVertical ? -deltaY : -deltaY)) *\n          stateRef.current.step;\n        currentPosition.current += delta * size;\n        stateRef.current.setThumbValue(\n          index,\n          stateRef.current.getThumbValue(index) + delta\n        );\n      } else {\n        let delta = isVertical ? deltaY : deltaX;\n        if (isVertical || reverseX) {\n          delta = -delta;\n        }\n        currentPosition.current += delta;\n        stateRef.current.setThumbPercent(\n          index,\n          clamp(currentPosition.current / size, 0, 1)\n        );\n      }\n    },\n    onMoveEnd() {\n      state.setThumbDragging(index, false);\n    },\n  });\n\n  // Immediately register editability with the state\n  state.setThumbEditable(index, !isDisabled);\n\n  const { focusableProps } = useFocusable(\n    mergeProps(opts, {\n      onFocus: () => state.setFocusedThumb(index),\n      onBlur: () => state.setFocusedThumb(undefined),\n    }),\n    inputRef\n  );\n\n  let currentPointer = useRef<number | undefined>(undefined);\n  let onDown = (id?: number) => {\n    focusInput();\n    currentPointer.current = id;\n    state.setThumbDragging(index, true);\n\n    addGlobalListener(window, 'mouseup', onUp, false);\n    addGlobalListener(window, 'touchend', onUp, false);\n    addGlobalListener(window, 'pointerup', onUp, false);\n  };\n\n  let onUp = (e) => {\n    let id = e.pointerId ?? e.changedTouches?.[0].identifier;\n    if (id === currentPointer.current) {\n      focusInput();\n      state.setThumbDragging(index, false);\n      removeGlobalListener(window, 'mouseup', onUp, false);\n      removeGlobalListener(window, 'touchend', onUp, false);\n      removeGlobalListener(window, 'pointerup', onUp, false);\n    }\n  };\n\n  // We install mouse handlers for the drag motion on the thumb div, but\n  // not the key handler for moving the thumb with the slider.  Instead,\n  // we focus the range input, and let the browser handle the keyboard\n  // interactions; we then listen to input's onChange to update state.\n  return {\n    inputProps: mergeProps(focusableProps, fieldProps, {\n      'type': 'range',\n      'tabIndex': !isDisabled ? 0 : undefined,\n      'min': state.getThumbMinValue(index),\n      'max': state.getThumbMaxValue(index),\n      'step': state.step,\n      'value': value,\n      'disabled': isDisabled,\n      'aria-orientation': opts.orientation,\n      'aria-valuetext': state.getThumbValueLabel(index),\n      'aria-required': isRequired || undefined,\n      'aria-invalid': validationState === 'invalid' || undefined,\n      'aria-errormessage': opts['aria-errormessage'],\n      'onChange': (e: ChangeEvent<HTMLInputElement>) => {\n        state.setThumbValue(index, parseFloat(e.target.value));\n      },\n    }),\n    thumbProps: !isDisabled\n      ? mergeProps(moveProps, {\n          onMouseDown: (e: React.MouseEvent<HTMLElement>) => {\n            if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n              return;\n            }\n            onDown();\n          },\n          onPointerDown: (e: React.PointerEvent<HTMLElement>) => {\n            if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n              return;\n            }\n            onDown(e.pointerId);\n          },\n          onTouchStart: (e: React.TouchEvent<HTMLElement>) => {\n            onDown(e.changedTouches[0].identifier);\n          },\n        })\n      : {},\n    labelProps,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}